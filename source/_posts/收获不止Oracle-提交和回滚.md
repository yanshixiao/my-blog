---
title: 收获不止Oracle-提交和回滚
date: 2018-03-13 18:56:18
tags: 提交 回滚 Oracle
categories: 收获不止Oracle
---

##### 提交

commit提交时并不一定会将缓存区的数据写入磁盘，从效率考虑肯定是积累到一定数量后批量保存。但就带来了安全问题，数据缓存区是内存空间，断电怎么办？其实commit时，日志会记录下当前操作。LGWR将操作写入redo日志，断电后只要再次执行，就不会丢失数据。

<!--more-->


运行过程中，批量刷出的数据占数据缓存区的比例越大，效率一般也越高，但断电后数据库重启恢复数据的时间也就更长，所以需要一个平衡。

真正控制数据缓存区数据什么时候写入磁盘的是CKPT进程。CKPT进程触发DBWR写数据。而凡事要有记录，DBWR要等待LGWR将日志记录完后才工作，如果LGWR挂掉，DBWR还是不会听从CKPT命令而罢工。长时间不COMMIT提交，CKPT自动触发DBWR将数据写入磁盘。

CKPT的触发时间可以用FAST START MTTR TARGET 参数调整。

##### 回滚

举个栗子。这样一条更新语句：update t set object_id=92 where object_id=29; 
	
1. 首先要查询object_id=29的记录，检查object_id=29的记录是否在缓存区中，不存在则从磁盘中读取到数据缓冲区中。
2. 在回滚表空间的响应回滚段事务表上分配事务槽，从而在回滚表空间分配到空间。该动作需要记录日志写进日志缓存区。
3. 在数据缓存区中创建object_id=29的前镜像，前镜像数据也会写进磁盘的数据文件里（回滚表空间的数据文件），当然也会记录日志并由LGWR写入磁盘形成redo文件。
4. 准备工作做好，允许数据修改，先记录进日志缓存区。
5. 如果用户提交，日志缓存区记录这个提交信息，然后把回滚段事务标记为非激活的INACTIVE状态，表示允许重写。
6. 如果执行回滚，就从回滚段中将前镜像object_id=29的数据读出来，修改数据缓存区，完成回滚。


![image](/images/2.png)
UNDO_MANAGEMENT为AUTO表示是自动回滚段管理，回滚段空间不够时可以自动扩展；UNDO_RETENTION为900表示DML语句需要记录前镜像，当COMMIT后，表示回滚段保留的前镜像被打上了可以覆盖重新使用的标记，但要在900秒后方可允许；UNDO_TABLESPACE为UNDOTBS1一眼就明白了。